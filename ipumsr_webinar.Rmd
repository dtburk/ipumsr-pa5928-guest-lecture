---
title: "Using IPUMS data in R with ipumsr"
author: "Derek Burk, Dan Ehrlich, & Kara Fisher"
date: "10/12/2021"
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  collapse = TRUE,
  comment = "#>"
)
```

# Overview

1. What is IPUMS?

--

2. What is ipumsr, and why use it?

--

3. Reading data into R

--

4. Exploring and manipulating metadata

--

5. Brief analysis example

--

6. Working with IPUMS geographic data

--

7. Preview of IPUMS API functionality

---

# Overview 1

<style>
  .greyed-out {
    color: #D3D3D3;
    text-indent: 20px;
  }
</style>

<style>
  .strong {
    color: #000000;
    text-indent: 20px;
  }
</style>

.greyed-out[


.strong[`1.` What is IPUMS?]

`2.` What is ipumsr, and why use it?

`3.` Reading data into R

`4.` Exploring and manipulating metadata

`5.` Brief analysis example

`6.` Working with IPUMS geographic data

`7.` Preview of IPUMS API functionality

]



# Overview 2

.greyed-out[


`1.` What is IPUMS?

.strong[`2.` What is ipumsr, and why use it?]

`3.` Reading data into R

`4.` Exploring and manipulating metadata

`5.` Brief analysis example

`6.` Working with IPUMS geographic data

`7.` Preview of IPUMS API functionality

]



# Overview 3

.greyed-out[


`1.` What is IPUMS?

`2.` What is ipumsr, and why use it?

.strong[`3.` Reading data into R]

`4.` Exploring and manipulating metadata

`5.` Brief analysis example

`6.` Working with IPUMS geographic data

`7.` Preview of IPUMS API functionality

]


---

class: center

# What is IPUMS?

--

## IPUMS is **data**

--

## from censuses and surveys around the world,

--

## integrated across space and time,

--

## thoroughly documented,

--

## and available for free at ipums.org

---

# What is ipumsr?

- R package developed by Greg Freedman Ellis

--

- Released in 2017

--

- Over 90,000 CRAN downloads

--

- Includes functions for
  - Reading IPUMS data
  - Exploring and manipulating IPUMS metadata
  - COMING SOON: Interacting with the IPUMS API
    
    
???
(Metadata such as value labels, variable labels, and detailed variable 
descriptions.)

Initial API support will be for IPUMS USA, with more projects to follow soon.



---

# Why use ipumsr?

- One package for IPUMS microdata, aggregate data, and geography

???
Regarding "One package": Without ipumsr, you'd need to use a variety of
different approaches from different packages to read in and explore IPUMS
microdata (from projects such as IPUMS USA, CPS, and International), IPUMS
aggregate data (from NHGIS or IHGIS), and IPUMS shapefiles. ipumsr provides one
package with a consistent interface for working with all these different types
of IPUMS data.

---

class: center middle inverse
background-image: url(https://comicvine.gamespot.com/a/uploads/original/5/52246/1963701-the_one_ring_02.jpg)
background-size: cover

<span role="img" aria-label="Slide background shows: The 'One Ring' from The Lord of the Rings set on a fiery background."></span>

# One package to rule them all

```{r echo=FALSE, fig.alt="Slide background shows: The 'One Ring' from The Lord of the Rings set on a fiery background."}
knitr::include_graphics("transparent_blank.png")
```

---

# Why use ipumsr?

- One package for IPUMS microdata, aggregate data, and geography

- Specialized functions for viewing and manipulating IPUMS metadata

--

- Bundled how-to guides (vignettes)

--

- Potential to add more features (e.g. API support); let us know what you want!
  - File an issue at https://github.com/mnpopcenter/ipumsr/issues
  - Email ipums+cran@umn.edu

???
Regarding "More features": The aforementioned IPUMS API support will be the next
big feature. Another potential new feature is adding tools for properly handling
survey weights. Let us know what would be helpful to you via GitHub or email.

---

# Why use ipumsr?

And finally... 

--

- It's fast!
  - Time to read 3 million rows with 13 variables:

```{r, echo=FALSE}
results <- readRDS("ipumsr_speed_test.rds")
suppressPackageStartupMessages({
  # library(ggplot2)
  library(dplyr)
  suppressWarnings(library(gt))
})
# ggplot(
#   data = results,
#   aes(x = reorder(function_name, desc(time)), y = time, fill = value_labels)
# ) +
#   geom_col() + 
#   coord_flip() +
#   labs(
#     title = "How long to read 3 million rows with 13 variables?",
#     y = "Seconds",
#     x = NULL
#   ) +
#   guides(fill = guide_legend("Includes value labels?"))
results %>% 
  arrange(time) %>% 
  mutate(time = round(time, 1)) %>% 
  rename(`Function` = function_name, `Time (seconds)` = time, 
         `With metadata?` = value_labels) %>% 
  gt() %>% 
  # tab_header("How long to read 3 million rows with 13 variables?") %>% 
  cols_align("center", c(`Time (seconds)`, `With metadata?`))
```

???
There are other ways to read IPUMS data into R, but ipumsr is the fastest way 
to read the data in with attached metadata, such as variable and value labels.

---

class: center, middle

# Poll: Have you used ipumsr?

---

# Installing ipumsr
```{r, eval = FALSE}
install.packages("ipumsr")
```

???
Now that we've convinced you of how great ipumsr is, you're probably asking 
"How do I get my hands on it?"

--

### Or if you want the development version

```{r, eval = FALSE}
if (!require(remotes)) install.packages("remotes")
remotes::install_github("mnpopcenter/ipumsr")
```

---

# Installing packages used in this webinar

This project uses [renv](https://rstudio.github.io/renv/articles/renv.html) to
track package dependencies.

--

To install required packages, [clone the repo](https://happygitwithr.com/existing-github-first.html#new-rstudio-project-via-git-clone), then use:

```{r eval=FALSE}
renv::restore()
```

---

# Downloading your data extract

```{r echo=FALSE, fig.alt="Screenshot of IPUMS data download page with the 'Download .DAT' and 'DDI' links highlighted"}
knitr::include_graphics("download_screenshot_1.png")
```

--

- Click the "Download .DAT" link to download the data

--

- Right-click the "DDI" link, and choose
    - "Save Link As..." (in Firefox)
    - "Save link as..." (in Chrome)
    - "Download Linked File" (in Safari)

???
Make sure to save the data and DDI files in the same location.

---

# Downloading your data extract

```{r echo=FALSE, fig.alt="Screenshot of IPUMS data download page with the 'R' link highlighted"}
knitr::include_graphics("download_screenshot_2.png")
```

- The "R" link on the downloads page contains this helper code:

```{r eval=FALSE}
# NOTE: To load data, you must download both the extract's data and the DDI
# and also set the working directory to the folder with these files (or change the path below).

if (!require("ipumsr")) stop("Reading IPUMS data into R requires the ipumsr package. It can be installed using the following command: install.packages('ipumsr')")

ddi <- read_ipums_ddi("ipumsi_00059.xml")
data <- read_ipums_micro(ddi)
```

???
This helper code checks that you have ipumsr installed, and if you do, it reads
in the DDI codebook and data into separate objects. As an aside, in case anyone
was curious, DDI stands for "Data Documentation Initiative" -- the DDI project
sets standards for documenting datasets, and the codebooks for most IPUMS
projects follow this standard.

We'll see this same code pattern in just a moment when we look at how to read 
in your data.

---

# Loading packages
```{r eval=FALSE}
library(ipumsr)
library(dplyr)
library(ggplot2)
library(stringr)
library(sf)
library(purrr)
library(DT)
```

```{r include=FALSE}
library(ipumsr)
library(dplyr)
library(ggplot2)
library(stringr)
library(sf)
library(purrr)
library(DT)
```

???
These packages are used in some of the examples we will walk through.

---

# Read in the data
- Using commands `read_ipums_ddi()` and `read_ipums_micro()`
```{r}
ddi <- read_ipums_ddi("usa_00013.xml")

data <- read_ipums_micro(ddi)
```

???
Here we see the same code pattern from the "R" helper file above, of reading the
metadata from the codebook into an object named "ddi", and using that object to 
read in the data.

---

# What's in that `ddi` object?

```{r}
names(ddi)
```

---

# What's in that `ddi` object?

```{r}
ddi$var_info
```


???
You don't need to know this to use ipumsr, but it might help you understand 
what is going on when you read in the DDI codebook and then the data.


---

# What's in my extract again?

--

Maybe I wrote an informative extract description?

```{r include=FALSE}
ddi$extract_notes <- 
  paste0(
    "User-provided description: Revision of(Revision of(Revision of(Revision ", 
    "of(my extract))))"
  )
```

```{r}
ddi$extract_notes
```

--

No such luck ðŸ˜ž

---

# What's in my extract again?

We can print the names of our variables:

--

```{r}
names(data)
```


But often variable names aren't self-explanatory.

--

Let's leverage that attached metadata.


---

# Available metadata
- Some (but not all) of the documentation comes with the ddi.
```{r}
ipums_var_label(ddi, PHONE)

ipums_var_desc(ddi, PHONE) %>% strwrap(60)
```

---

# Available metadata
```{r}
ipums_val_labels(ddi, PHONE)
```

---


# A nicer view of metadata

```{r, eval=FALSE}
ipums_view(ddi)
```

```{r echo=FALSE, fig.alt="Screenshot of static html page generated by function 'ipums_view', showing variable label and variable description for the variable 'PHONE'."}
knitr::include_graphics("ipums_view_screenshot.png")
```

???
The function ipums_view() makes a nicely-formatted static html page that allows 
you to browse the metadata associated with your data extract.

---


# Data
A regular `tbl_df` data.frame
```{r}
data
```

---

# Wrangling value labels

- IPUMS value labels don't translate that well to R's factors.

    - (Factors always have a label, and always have values starting at 1)
  
- So `ipumsr` imports them as `haven::labelled()` objects, which aren't
  always the easiest to deal with.

- Luckily ipumsr provides helpers that allow you to use information
  from both the value and label

```{r, include = FALSE}
label_before_after <- function(df, before_var, after_var, label_fun) {
  before_var <- rlang::enquo(before_var)
  after_var <- rlang::enquo(after_var)

  
  freqs <- df %>% 
    mutate(val = !!before_var) %>%
    group_by(val) %>%
    summarize(count = n()) 
  
  all_vals <- ipums_val_labels(df, !!before_var) %>% pull(val)
  attributes(all_vals) <- attributes(df %>% pull(!!before_var))
  
  unique_val_df <- dplyr::tibble(val = all_vals) %>%
    mutate(
      after = label_fun(val),
      `before ([val] label)` = as_factor(val, "both")
    ) %>%
    filter(after %in% levels(df %>% pull(!!after_var)) | is.na(after))
  
  attributes(unique_val_df$val) <- NULL
  attributes(freqs$val) <- NULL
  
  out <- left_join(unique_val_df, freqs, by = "val") %>%
    mutate(count = ifelse(is.na(count), 0, count)) %>%
    select(`before ([val] label)`, after, count)
  
  out %>%
    DT::datatable(
      rownames = FALSE, 
      filter = "none", 
      options = list(
        searching = FALSE, 
        scrollY = "200px",
        scrollCollapse = TRUE,
        paging = FALSE,
        bInfo = FALSE
      )
    )
}
```

---

# `as_factor()`
- `as_factor()` (from haven) converts directly to a factor.

```{r}
ipums_val_labels(data$GQ)
```

---

# `as_factor()`

- Suppose we want to keep these labels exactly as they are.

```{r}
data$GQ2 <- as_factor(data$GQ)
```

. . .

```{r, echo = FALSE}
label_before_after(data, GQ, GQ2, as_factor)
```

---

# `lbl_clean()`
- `lbl_clean()` gets rid of unused value labels.

```{r}
ipums_val_labels(data$STATEFIP)
```

---

# `lbl_clean()`
- Since our extract only has Minnesota, we don't want all of
 these values.

```{r}
data$STATEFIP2 <- data$STATEFIP %>% 
  lbl_clean() %>% 
  as_factor()
```

. . .

```{r, echo = FALSE}
label_before_after(data, STATEFIP, STATEFIP2, . %>% lbl_clean() %>% as_factor())
```

---

# `lbl_na_if()`
- `lbl_na_if()` allows you to set certain values or labels 
  to missing.

```{r}
ipums_val_labels(data$PHONE)
```

---

# `lbl_na_if()`

- Easier to use R's `NA` data structure to deal with missing values
  like "N/A" and "Suppressed".

```{r}
data$PHONE2 <- lbl_na_if(data$PHONE, ~.val %in% c(0, 8)) %>%
  as_factor()
```

. . . 

```{r, echo = FALSE}
label_before_after(
  data, 
  PHONE, 
  PHONE2,
  . %>% 
    lbl_na_if(~.val %in% c(0, 8)) %>%
    as_factor()
)
```

---

# `lbl_na_if()`
- It works with both values (`.val`) and labels (`.lbl`).
  So we could have also written something like this:
```{r}
drop_labels <- c("N/A", "Suppressed (2012 and 2015 ACS)")

data$PHONE3 <- lbl_na_if(data$PHONE, ~.lbl %in% drop_labels) %>%
  as_factor()
```

---

# `lbl_collapse()`
- `lbl_collapse()` allows you to take advantage of the hierarchical
  structure of value labels.
```{r}
ipums_val_labels(data$EDUCD)
```

---

# `lbl_collapse()`

- Maybe this is too much detail, so we want to collapse 
  the last digit.

```{r}
data$EDUCD2 <- lbl_collapse(data$EDUCD, ~.val %/% 10) %>%
  as_factor()
```

. . .

```{r, echo = FALSE}
label_before_after(
  data, 
  EDUCD, 
  EDUCD2,
  . %>% lbl_collapse(~.val %/% 10) %>%
    as_factor()
)
```

---

# `lbl_relabel()`
- `lbl_relabel()` has more granular control of what the values are assigned to.

```{r}
levels(data$EDUCD2)
```

---

# `lbl_relabel()`

- Maybe the education variable is still too specific.

```{r}
data$EDUCD3 <- data$EDUCD %>%
  lbl_collapse(~.val %/% 10) %>% 
  lbl_relabel(
    lbl(2, "Less than High School") ~.val > 0 & .val < 6,
    lbl(3, "High school") ~.lbl == "Grade 12",
    lbl(4, "Some college") ~str_detect(.lbl, "^[123] year(s)? of college$"),
    lbl(5, "College or more") ~.val %in% c(10, 11)
  ) %>%
  as_factor()
```

---

# `lbl_relabel()`

```{r, echo = FALSE}
label_before_after(
  data, 
  EDUCD, 
  EDUCD3,
  . %>%
    lbl_collapse(~.val %/% 10) %>% 
    lbl_relabel(
      lbl(2, "Less than High School") ~.val > 0 & .val < 6,
      lbl(3, "High school") ~.lbl == "Grade 12",
      lbl(4, "Some college") ~str_detect(.lbl, "^[123] year(s)? of college$"),
      lbl(5, "College or more") ~.val %in% c(10, 11)
    ) %>%
    as_factor()
)
```

---
class: center middle

# Brief analysis example

---

# Phone availability 
- Now that they're factors, ready for use as regular R data
```{r graph1, eval=FALSE}
graph_data <- data %>%
  group_by(YEAR) %>%
  summarize(`% with phone` = weighted.mean(
    PHONE2 == "Yes, phone available", PERWT, na.rm = TRUE
  ))

ggplot(graph_data, aes(x = YEAR, y = `% with phone`)) +
  geom_point() +
  geom_line() + 
  labs(
    title = "Percent of Minnesota with phone line",
    subtitle = paste0("Data source: ", ddi$ipums_project),
    caption = paste(strwrap(ipums_var_desc(ddi, PHONE), 90), collapse = "\n")
  )
```

---

# Phone availability
```{r graph1, dpi=300, fig.height=4, fig.width=6, echo = FALSE}
```

---

# Interpretation

> The 2008 ACS and 2008 PRCS instructed respondents to include cell 
> phone service; prior to 2008, this was not made explicit.
> 
> - https://usa.ipums.org/usa-action/variables/PHONE#comparability_section

---

# Phone availability by education
```{r graph2, dpi=300, fig.height=4, fig.width=6, echo = FALSE}
graph_data <- data %>%
  group_by(YEAR, EDUCD3) %>%
  summarize(`% with phone` = weighted.mean(
    PHONE2 == "Yes, phone available", PERWT, na.rm = TRUE
  ), .groups = "drop")

ggplot(graph_data, aes(x = YEAR, y = `% with phone`)) +
  geom_point() +
  geom_line() + 
  facet_wrap(~EDUCD3) + 
  labs(
    title = "Percent of Minnesota with phone line by education",
    subtitle = paste0("Data source: ", ddi$ipums_project)
  )
```

---

class: center middle

# Geographic data

---

# Getting geographic data
- For IPUMS USA (and several other projects), we provide geographic
  boundaries as well. For many areas, this includes harmonizing
  boundary changes over time.

- In our extract we included CONSPUMA, so let's checkout the 
  description on the website 
  (https://usa.ipums.org/usa/volii/tgeotools.shtml)
  about it.

- Note that CONSPUMA is a rather large geography, if you 
  want finer geographic detail, you need to hope that
  NHGIS has the table you want.

---

# Loading shape data
- `ipumsr` provides support for both sf and sp data, but I find the sf
  package much easier to use.

- To use, use the `ipums_read_sf()` function. (Mostly just a wrapper around
  `sf::read_sf`).


```{r}
shape_data <- read_ipums_sf("shape/")
```

---

# Joining shape data
- We also provide helpers for merging data that work with both sf
  and sp packages. 

```{r}
conspuma_data <- data %>%
  group_by(CONSPUMA, YEAR) %>%
  summarize(PHONE = weighted.mean(
    PHONE2 == "Yes, phone available", PERWT, na.rm = TRUE
  ))

conspuma_data <- ipums_shape_inner_join(
  conspuma_data, 
  shape_data, 
  by = "CONSPUMA"
)
```

---

# Plotting shape data
- With the development version of ggplot2, can plot sf data:
```{r graph3, dpi=300, fig.height=4, fig.width=6, echo = FALSE}
graph_data <- conspuma_data %>% 
  filter(YEAR %in% c(1980, 1990, 2000, 2010))

ggplot(graph_data, aes(fill = PHONE)) +
  facet_wrap(~YEAR) + 
  geom_sf()
```

---

# Thanks!
- Email: ipums+cran@umn.edu

- ipumsr github: https://github.com/mnpopcenter/ipumsr

- This presentation: https://github.com/dtburk/ipumsr-webinar